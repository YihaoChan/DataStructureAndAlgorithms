# 第9题 回文数

## 1 题目

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

示例 1：

```
输入：x = 121
输出：true
```

示例 2：

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

示例 3：

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

示例 4：

```
输入：x = -101
输出：false
```

## 2 解法

### 2.1 转换成字符串

```
class Solution {
    public boolean isPalindrome(int x) {
        String str = String.valueOf(x);

        int left = 0;
        int right = str.length() - 1;

        while (left <= right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }

            left++;
            right--;
        }

        return true;
    }
}
```

复杂度分析：

记n为x的位数。

1. 时间复杂度：最坏情况下每个字符都搜索一遍，故时间复杂度为**O(n)**；
2. 空间复杂度：转换成字符串需要占用额外空间，故空间复杂度为**O(n)**。

### 2.2 反转后半部分

如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

首先，负数不可能是回文数，因为最前面有负号，而最后面不可能有负号。其次，除0以外，以0结尾的数不可能是回文数，因为正数不可能以0开头。

对于数字1221，如果执行1221 % 10，我们将得到最后一位数字1，要得到倒数第二位数字，可以先将原数除以10，即1221 / 10 = 122，再求出122的个位数字，122 % 10 = 2，就可以得到倒数第二位数字。如果把原数的最后一位数字乘以10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了原数后半部分的反转数。

如何判断反转数字的位数已经达到原始数字位数的一半？由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，因此，当原始数字小于或等于反转后的数字时，就意味着已经反转了数字的后半部分。

```
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || (x > 0 && x % 10 == 0)) {
            return false;
        }

        int reverseHalf = 0;

        while (x > reverseHalf) {
            reverseHalf = reverseHalf * 10 + x % 10;
            x /= 10;
        }

        return x == reverseHalf || x == reverseHalf / 10;
    }
}
```

注意：12321操作后的结果为，reverseHalf == 123，x == 12，因为中间多出一位3导致了不同结果。此时，将reverseHalf除以10，再与x判断即可。

复杂度分析：

1. 时间复杂度：记n为x的值，12321花费3次，1221花费2次，时间是对数级别，故时间复杂度为**O(logn)**，其中log以10为底；
2. 空间复杂度：仅花费常数个额外空间，故空间复杂度为**O(1)**。





