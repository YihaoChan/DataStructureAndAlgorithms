# 第1004题 最大连续1的个数 III

## 1 题目

给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

示例 1：

```
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```

示例 2：

```
输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
```

## 2 解法

滑动窗口。通过快慢指针形成一个窗口，当快指针遍历到0时，满足条件的数字数量+1。当满足的数量到达K+1时，开始收缩窗口，同时更新最大子数组长度。当慢指针指向的元素为0时，满足条件的数字数量-1。当遍历结束时，有可能出现的情况是：快指针一路都是遇到1，所以不用增加满足的数量，实际上这种情况也有可能使得连续1的个数比较大，而此时并没有也不需要收缩窗口而更新子数组长度。所以，在跳出循环时，需要判断快指针-慢指针和已知最大长度的大小。

典型用例：[1,1,1,0,0,0,1,1,1,1]，K = 0.

```
class Solution {
    public int longestOnes(int[] A, int K) {
        int len = A.length;

        int left = 0;
        int right = 0;

        int satisfy = 0;

        int subArrLen = 0;

        for (right = 0; right < len; right++) {
            int item = A[right];

            if (item == 0) {
                satisfy++;
            }

            while (satisfy == K + 1) {
                if (right - left > subArrLen) {
                    subArrLen = right - left;
                }

                int removeItem = A[left];

                left++;

                if (removeItem == 0) {
                    satisfy--;
                }
            }
        }

        return (right - left > subArrLen) ? right - left : subArrLen;
    }
}
```

复杂度分析：

1. 时间复杂度：right遍历花费O(n)，left最多移动n次，故时间复杂度为**O(n)**；
2. 空间复杂度：仅用到常数个额外空间，故空间复杂度为**O(1)**。

